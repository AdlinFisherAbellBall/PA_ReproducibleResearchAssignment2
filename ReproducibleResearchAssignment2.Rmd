---
title: "ReproducibleResearchAssignment2"
author: "Adlin Fisher Abell Ball"
date: "2023-06-10"
output: html_document
---
  The purpose of this document is to provide an analysis of the data provided
  which was taken from the National Oceanic and Atmospheric Administration
  and contains information from the 1950 through to November of 2011. In 1996
  the NOAA began recording any event types that caused injury to persons or 
  damage to property. See the 
  [NOAA Website](https://www.ncdc.noaa.gov/stormevents/details.jsp?type=eventtype)
  for more information. Then for the sake of consistency of the data collection
  process, this analysis will use the data available from the year 1996 and
  onward.
```{r}
library(ggplot2)
damage = read.csv(bzfile("repdata_data_StormData.csv.bz2"))
damage$BGN_DATE = strptime(damage$BGN_DATE, tz='', '%m/%d/%Y %H:%M:%OS')
damage96 = damage[damage$BGN_DATE > strptime('1996-01-01', '%F'),
                  1:length(colnames(damage))]
```

Now, to begin we must prepare the data for calculating the financial impact.
For this, I drop all the irrelevent rows in order to save time in operating on
the data. Note that the `PROPDMGEXP` and `CROPDMGEXP` columns contain a factor
that encodes the amount of damage in the `PROPDMG` and `CROPDMG` columns 
respectively. In this scheme, `K` indicates that the column damages are in
thousands of dollars, `M` indicates millions, and `B` indicates billions. There
are other values in the encoding columns, but since these are not accounted for
in the
[data documentation](https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf),
the rows associated with these entries are discarded.

```{r}
# First, for efficiency's sake I select only the relevant columns for this 
# analysis.
columns = c('BGN_DATE', 'PROPDMG', 'PROPDMGEXP', 'CROPDMG', 'CROPDMGEXP',
            'EVTYPE', 'REFNUM')
QuantDam = damage96[columns]

#Next, I will discard all of the data that does not have its costs properly
# prepared.
QuantDam = QuantDam[(QuantDam$PROPDMG == 0)|
                      (QuantDam$PROPDMGEXP %in% c('K', 'M', 'B', '')), 
                    1:length(colnames(QuantDam)) ]
QuantDam = QuantDam[(QuantDam$CROPDMG == 0)|
                      (QuantDam$CROPDMGEXP %in% c('K', 'M', 'B', '')), 
                    1:length(colnames(QuantDam)) ]

totaldamage = rep(0, dim(QuantDam)[1])
ttldmg2023 = rep(0, dim(QuantDam)[1])

# Below I combine the total damages to both crops and property while calculating
# the costs.

pks = (QuantDam$PROPDMGEXP == 'K' | QuantDam$PROPDMGEXP == 'k')
totaldamage = totaldamage + QuantDam$PROPDMG * pks * 10^3
remove(pks)

pms = (QuantDam$PROPDMGEXP == 'M')
totaldamage = totaldamage + QuantDam$PROPDMG * pms * 10^6
remove(pms)

pbs = (QuantDam$PROPDMGEXP == 'B')
totaldamage = totaldamage + QuantDam$PROPDMG * pbs * 10^9
remove(pbs)

cks = (QuantDam$CROPDMGEXP == 'K' | QuantDam$CROPDMGEXP == 'k')
totaldamage = totaldamage + QuantDam$CROPDMG * cks * 10^3
remove(cks)

cms = (QuantDam$CROPDMGEXP == 'M')
totaldamage = totaldamage + QuantDam$CROPDMG * cms * 10^6
remove(cms)

cbs = (QuantDam$CROPDMGEXP == 'B')
totaldamage = totaldamage + QuantDam$CROPDMG * cbs * 10^9
remove(cbs)
```

 Since the value of a dollar is not constant accross time, I also wish to 
 account for inflation in my analysis of economic damages. To do this, I used
 the
 [Bureau of Labor Statistics CPI Database](https://beta.bls.gov/dataViewer/view/timeseries/CUSR0000SA0) 
 (accessed June 12, 2023) to get the inflation index. The calculations to
 convert the damages to May 2023 dollars are below:

```{r}
# First, I initialize a couple vectors for our calculations.
eventCPI = rep(0, dim(QuantDam)[1])
ttldmg2023 = rep(0, dim(QuantDam)[1])

# Now I read in the CPI data.
QuantDam = cbind(QuantDam, TOTALDMG = totaldamage)
CPI = read.csv('CPI.csv')

# Now I convert the times to date-time objects. Then I take the weather event
# beginning dates and convert them to the first of their month in order to match
# the CPI for that date to the data from the CPI database. Then I remove
# superflous vectors since they are a non-trivial amount of storage.
CPI$Label = strptime(paste(CPI$Label, '01'), '%Y %b %d')
CPIperiod = strptime(paste(format(QuantDam$BGN_DATE, "%Y-%m"),
                           '01', sep= '-'), format = '%Y-%m-%d')
periodind = match(CPIperiod, CPI$Label)
for (i in 1:length(CPIperiod)) {
  eventCPI[i] = CPI$Value[periodind[i]]
}
remove(CPIperiod, periodind)

# Lastly, take the most current CPI at time of writing and calculate the total
# total damages for each event in May 2023 Dollars.
NowCPI = CPI$Value[match(strptime('2023-05-01', '%Y-%m-%d'), CPI$Label)]
ttldmg2023 = (NowCPI/eventCPI) * totaldamage
QuantDam = cbind(QuantDam, TOTAL2023DMG = as.numeric(ttldmg2023))
```

Lastly, before the final analysis of the economic impact of the recorded events,
the inconsistent labelling needs to be addressed. There are
`r length(unique(QuantDam$EVTYPE))` different event-type labels, but there
repeats and entries that are needlessly specific.

```{r}
QuantDam$EVTYPE[grep('hurricane', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = 'HURRICANE/TYPHOON'
QuantDam$EVTYPE[grep('typhoon', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = 'HURRICANE/TYPHOON'
QuantDam$EVTYPE[grep('damaging freeze', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = 'DAMAGING FREEZE'
QuantDam$EVTYPE[grep('flood', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = 'FLOOD'
QuantDam$EVTYPE[grep('fld', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = 'FLOOD'
QuantDam$EVTYPE[grep('thunderstorm', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = "THUNDERSTORM"
QuantDam$EVTYPE[grep('tstm', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = "THUNDERSTORM"
QuantDam$EVTYPE[grep('freeze', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = "FROST/FREEZE"
QuantDam$EVTYPE[grep('frost', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = "FROST/FREEZE"
QuantDam$EVTYPE[grep('storm surge', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = 'STORM SURGE/TIDE'
QuantDam$EVTYPE[grep('high tide', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = 'STORM SURGE/TIDE'
QuantDam$EVTYPE[grep('wild fire', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = 'WILD/FOREST FIRE'
QuantDam$EVTYPE[grep('wildfire', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = 'WILD/FOREST FIRE'
coldtags = unique(QuantDam$EVTYPE)[grep('cold', 
                                        unique(QuantDam$EVTYPE),
                                        ignore.case = TRUE)]
coldtags
```

As we can see above, there are multiple redundant tags for cold whether or
windchill, but not every event descriptor that contains the word "cold" is 
equivalent. Since all of these event titles except "COLD AND SNOW" appear to be
used to describe events that are characterized by cold tempuratures, windchill,
or some combination of the two, it is intuitive to combine them. Note that since
cold and snow includes snow in its characteristic conditions, it will be
excluded. 

```{r}
coldtags = coldtags[coldtags != 'COLD AND SNOW']

for (i in 1:length(coldtags)) {
  QuantDam$EVTYPE[grep(coldtags[i], QuantDam$EVTYPE,
                     ignore.case = TRUE)] = "COLD/WIND CHILL"
}
QuantDam$EVTYPE[grep('windchill', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = "COLD/WIND CHILL"

QuantDam$EVTYPE[grep('wind chill', QuantDam$EVTYPE,
                     ignore.case = TRUE)] = "COLD/WIND CHILL"

totaldamages = aggregate(QuantDam$TOTAL2023DMG, list(QuantDam$EVTYPE),
                         FUN = sum)
names(totaldamages) = c('evtype', 'dmg')
top15 = order(totaldamages$dmg, decreasing = TRUE)[1:15]
QuantDam1 = QuantDam[QuantDam$EVTYPE %in% totaldamages$evtype[top15] &
                       QuantDam$TOTALDMG != 0, ]

hurmed = median(QuantDam1$TOTAL2023DMG[QuantDam1$EVTYPE == 'HURRICANE/TYPHOON'])
drtmed = median(QuantDam1$TOTAL2023DMG[QuantDam1$EVTYPE == 'DROUGHT'])
fstmed = median(QuantDam1$TOTAL2023DMG[QuantDam1$EVTYPE == 'FROST/FREEZE'])
napadmg = format(max(QuantDam1$TOTAL2023DMG[QuantDam1$EVTYPE == 'FLOOD']),
                 big.mark = ',')
fldmed = format(median(QuantDam1$TOTAL2023DMG[QuantDam1$EVTYPE == 'FLOOD']),
                big.mark = ',')

ggplot(data = QuantDam1) +
  geom_boxplot(mapping = aes(x = reorder(EVTYPE , TOTAL2023DMG+1, median),
                             TOTAL2023DMG, fill = EVTYPE,
                             color = EVTYPE),
               outlier.color = 'dark gray') +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
   scale_fill_manual(values = rep("light blue", 15)) +
   scale_color_manual(values = rep('black',15)) +
  scale_y_log10(name = "Median Damage \n (log+1 Dollars as of May, 2023)") +
  scale_x_discrete(name = 'Event Type Ordered by Median Damage')

remove(CPI, QuantDam, QuantDam1)
```

Note that the above graph is of only the events that did some amount of damage,
with events that did no damage excluded. With that in mind, we can see that the 
event category that has the highest median damages is hurricanes and typhoons 
with a median of $`r format(hurmed, big.mark=',')`.
The categories with the second and third highest median damages are drought,
with median damages of $`r format(drtmed, digits = 2, big.mark=',')`, and 
freezing/frosts, with a median of $`r format(fstmed, digits = 2, big.mark=',')`.
This graph also reveals a number of outlying points. The most prominent is the
event with the single highest damage, which comes from the flooding category.
This event's damages total to $`r napadmg`, the highest of any single event.
Compare this with the flood category's median of $`r fldmed`. This event is the
Napa Valley flooding of 2005.

Now for the human damage of these events. For this we will once again drop the
irrelevant categories. For consistency's sake, we will consolidate the event
type tags the same way as we did previously.

```{r}
HumDmg = damage96[, c('EVTYPE', 'REFNUM', 'INJURIES', 'FATALITIES')]


HumDmg$EVTYPE[grep('hurricane', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = 'HURRICANE/TYPHOON'
HumDmg$EVTYPE[grep('typhoon', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = 'HURRICANE/TYPHOON'
HumDmg$EVTYPE[grep('damaging freeze', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = 'DAMAGING FREEZE'
HumDmg$EVTYPE[grep('flood', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = 'FLOOD'
HumDmg$EVTYPE[grep('fld', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = 'FLOOD'
HumDmg$EVTYPE[grep('thunderstorm', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = "THUNDERSTORM"
HumDmg$EVTYPE[grep('tstm', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = "THUNDERSTORM"
HumDmg$EVTYPE[grep('freeze', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = "FROST/FREEZE"
HumDmg$EVTYPE[grep('frost', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = "FROST/FREEZE"
HumDmg$EVTYPE[grep('storm surge', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = 'STORM SURGE/TIDE'
HumDmg$EVTYPE[grep('high tide', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = 'STORM SURGE/TIDE'
HumDmg$EVTYPE[grep('wild fire', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = 'WILD/FOREST FIRE'
HumDmg$EVTYPE[grep('wildfire', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = 'WILD/FOREST FIRE'
coldtags = unique(HumDmg$EVTYPE)[grep('cold', 
                                        unique(HumDmg$EVTYPE),
                                        ignore.case = TRUE)]
coldtags = coldtags[coldtags != 'COLD AND SNOW']

for (i in 1:length(coldtags)) {
  HumDmg$EVTYPE[grep(coldtags[i], HumDmg$EVTYPE,
                     ignore.case = TRUE)] = "COLD/WIND CHILL"
}
HumDmg$EVTYPE[grep('windchill', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = "COLD/WIND CHILL"

HumDmg$EVTYPE[grep('wind chill', HumDmg$EVTYPE,
                     ignore.case = TRUE)] = "COLD/WIND CHILL"

CASUALTIES = HumDmg$INJURIES + HumDmg$FATALITIES

HumDmg = cbind(HumDmg, CASUALTIES)

totalcasualties = aggregate(HumDmg[,c('INJURIES', 'FATALITIES', 'CASUALTIES')], list(HumDmg$EVTYPE), sum)

top15 = order(totalcasualties$CASUALTIES, decreasing = TRUE)[1:15]
totalcasualties[top30,]

HumDmg1 = HumDmg[HumDmg$CASUALTIES != 0,]
```